"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PrometheusModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrometheusModule = void 0;
const common_1 = require("@nestjs/common");
const promClient = require("prom-client");
const constants_1 = require("./constants");
const controller_1 = require("./controller");
/**
 * The primary entrypoint. This should be registered once in the root application module.
 *
 * @public
 */
let PrometheusModule = PrometheusModule_1 = class PrometheusModule {
    static register(options) {
        const opts = PrometheusModule_1.makeDefaultOptions(options);
        PrometheusModule_1.configureServer(opts);
        const providers = [
            {
                provide: constants_1.PROMETHEUS_OPTIONS,
                useValue: options,
            },
        ];
        if ((options === null || options === void 0 ? void 0 : options.pushgateway) !== undefined) {
            const { url, options: gatewayOptions, registry } = options.pushgateway;
            providers.push({
                provide: promClient.Pushgateway,
                useValue: PrometheusModule_1.configurePushgateway(url, gatewayOptions, registry),
            });
        }
        return {
            module: PrometheusModule_1,
            global: opts.global,
            providers,
            controllers: [opts.controller],
            exports: providers,
        };
    }
    static registerAsync(options) {
        var _a;
        const providers = this.createAsyncProviders(options);
        const controller = (_a = options.controller) !== null && _a !== void 0 ? _a : controller_1.PrometheusController;
        return {
            module: PrometheusModule_1,
            global: options.global,
            controllers: [controller],
            imports: options.imports,
            providers: [
                ...providers,
                {
                    provide: constants_1.PROM_CLIENT,
                    inject: [constants_1.PROMETHEUS_OPTIONS],
                    useFactory(userOptions) {
                        const opts = PrometheusModule_1.makeDefaultOptions(userOptions);
                        PrometheusModule_1.configureServer(opts);
                        return promClient;
                    },
                },
            ],
            exports: [...providers],
        };
    }
    static createAsyncProviders(options) {
        if (options.useExisting || options.useFactory) {
            return [
                this.createAsyncOptionsProvider(options),
                PrometheusModule_1.createPushgatewayProvider(),
            ];
        }
        else if (!options.useClass) {
            throw new Error("Invalid configuration. Must provide useClass or useExisting");
        }
        return [
            this.createAsyncOptionsProvider(options),
            {
                provide: options.useClass,
                useClass: options.useClass,
            },
            PrometheusModule_1.createPushgatewayProvider(),
        ];
    }
    static createAsyncOptionsProvider(options) {
        if (options.useFactory) {
            return {
                provide: constants_1.PROMETHEUS_OPTIONS,
                // eslint-disable-next-line @typescript-eslint/unbound-method
                useFactory: options.useFactory,
                inject: options.inject || [],
            };
        }
        const inject = options.useClass || options.useExisting;
        if (!inject) {
            throw new Error("Invalid configuration. Must provide useClass or useExisting");
        }
        return {
            provide: constants_1.PROMETHEUS_OPTIONS,
            async useFactory(optionsFactory) {
                return optionsFactory.createPrometheusOptions();
            },
            inject: [inject],
        };
    }
    static configureServer(options) {
        if (options.defaultMetrics.enabled) {
            promClient.collectDefaultMetrics(options.defaultMetrics.config);
        }
        if (Object.keys(options.defaultLabels).length > 0) {
            promClient.register.setDefaultLabels(options.defaultLabels);
        }
        Reflect.defineMetadata("path", options.path, options.controller);
    }
    static configurePushgateway(url, options, registry) {
        return new promClient.Pushgateway(url, options, registry);
    }
    static createPushgatewayProvider() {
        return {
            provide: promClient.Pushgateway,
            inject: [constants_1.PROMETHEUS_OPTIONS],
            useFactory(options) {
                if ((options === null || options === void 0 ? void 0 : options.pushgateway) !== undefined) {
                    const { url, options: gatewayOptions, registry, } = options.pushgateway;
                    return PrometheusModule_1.configurePushgateway(url, gatewayOptions, registry);
                }
                return null;
            },
        };
    }
    static makeDefaultOptions(options) {
        return {
            global: false,
            path: "/metrics",
            defaultMetrics: {
                enabled: true,
                config: {},
            },
            controller: controller_1.PrometheusController,
            defaultLabels: {},
            ...options,
        };
    }
};
exports.PrometheusModule = PrometheusModule;
exports.PrometheusModule = PrometheusModule = PrometheusModule_1 = __decorate([
    (0, common_1.Module)({})
], PrometheusModule);
//# sourceMappingURL=module.js.map